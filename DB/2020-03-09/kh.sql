
--SUM은 그룹함수이기에 여러줄이 출력되는 DEPT_CODE와 에러가 생긴다.
SELECT DEPT_CODE, SUM(SALARY) FROM EMPLOYEE;
SELECT DEPT_CODE FROM EMPLOYEE;
SELECT SUM(SALARY) FROM EMPLOYEE;

--그룹함수인 SUM과 동시에 사용하기 위해서는 GROUP BY로 그룹함수가 아닌 것을 묶을 필요가 있다.
SELECT DEPT_CODE, SUM(SALARY), FLOOR(AVG(SALARY)) AS "평균", COUNT(*) AS "인원"
FROM EMPLOYEE
GROUP BY DEPT_CODE;

--새로 만들어낸 컬럼도 GROUP BY가 가능하다.
SELECT
    DECODE(SUBSTR(EMP_NO, 8, 1), 1, '남', 2, '여') AS "성별",
    FLOOR(AVG(SALARY)) AS "평균",
    SUM(SALARY) AS "합계",
    COUNT(*) AS "인원수"
FROM EMPLOYEE
GROUP BY DECODE(SUBSTR(EMP_NO, 8, 1), 1, '남', 2, '여');

--부서별 평균 급여
SELECT DEPT_CODE, FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING FLOOR(AVG(SALARY)) > 3000000;

--JOIN
SELECT EMP_ID, EMP_NAME, DEPT_CODE
FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;

--ORACLE 전용
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

--ANSI 표준 JOIN
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

--컬럼명이 동일할 때
SELECT EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);

SELECT EMP_NAME, EMPLOYEE.JOB_CODE, JOB_NAME
FROM EMPLOYEE, JOB
WHERE JOB.JOB_CODE = EMPLOYEE.JOB_CODE;

SELECT EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);

--INNER JOIN
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

--OUTER JOIN
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
RIGHT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
FULL JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
CROSS JOIN DEPARTMENT;

--SELF JOIN : 별칭을 사용한다.
SELECT E1.EMP_NAME, E1.MANAGER_ID, E2.EMP_NAME AS "관리자 이름"
FROM EMPLOYEE E1
JOIN EMPLOYEE E2 ON (E1.MANAGER_ID = E2.EMP_ID);

SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;
SELECT * FROM EMPLOYEE;
SELECT * FROM SAL_GRADE;
SELECT * FROM NATIONAL;
SELECT * FROM JOB;

SELECT EMP_NAME, SALARY, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE);

--1. 2020년 12월 25일이 무슨 요일인지 조회하시오.
SELECT TO_CHAR(TO_DATE('2020-12-25', 'YYYY-MM-DD'), 'DAY') AS "요일" FROM DUAL;

--2. 주민번호가 1970년대 생이면서 성별이 여자이고,
-- 성이 전씨인 직원들의 사원명, 주민번호, 부서명, 직급명을 조회하시오.
SELECT EMP_NAME, EMP_NO, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING(JOB_CODE)
WHERE 
    TO_DATE(SUBSTR(EMP_NO, 1, 2), 'RR') BETWEEN '1970-01-01' AND '1979-12-31'
    AND EMP_NO LIKE '______-2%'
    AND SUBSTR(EMP_NAME, 1, 1) = '전';

--3. 이름에 '형'자가 들어가는 직원들의
--사번, 사원명, 부서명을 조회하시오.
SELECT EMP_ID, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE EMP_NAME LIKE '%형%';

--4. 해외영업부에 근무하는
--사원명, 직급명, 부서코드, 부서명을 조회하시오.
SELECT EMP_NAME AS "사원명", JOB_NAME AS "직급명", DEPT_CODE AS "부서코드", DEPT_TITLE AS "부서명"
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING(JOB_CODE)
WHERE DEPT_TITLE LIKE '해외영업%';

--5. 보너스 포인틀르 받는 직원들의
--사원명, 보너스포인트, 부서명, 근무지역명을 조회하시오.
SELECT EMP_NAME, BONUS, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
LEFT JOIN LOCATION ON (LOCAL_CODE = LOCATION_ID)
WHERE BONUS IS NOT NULL;

--6. 부서코드가 D2인 직원들의
--사원명, 직급명, 부서명, 근무지역명을 조회하시오.
SELECT EMP_NAME AS "사원명", JOB_NAME AS "직급명", DEPT_TITLE AS "부서명", LOCAL_NAME AS "근무지역명"
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCAL_CODE = LOCATION_ID)
JOIN JOB USING(JOB_CODE)
WHERE DEPT_CODE = 'D2';

--7. 급여등급테이블의 최대급여(MAX_SAL) -50만원 보다 많이 받는 직원들의
--사원명, 직급명, 급여, 연봉을 조회하시오.
--(사원 테이블과 급여등급 테이블을 SAL_LEVEL 컬럼 기준으로 조인할 것)
SELECT EMP_NAME AS "사원명", JOB_NAME AS "직급명", SALARY AS "급여", SALARY * 12 AS "연봉", MAX_SAL AS "최대급여"
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN SAL_GRADE USING(SAL_LEVEL)
WHERE SALARY > MAX_SAL - 500000;

--8. 한국(KO)과 일본(JP)에 근무하는 직원들의
--사원명, 부서명, 지역명, 국가명을 조회하시오.
SELECT EMP_NAME AS "사원명", DEPT_TITLE AS "부서명", LOCAL_NAME AS "지역명", NATIONAL_NAME AS "국가명"
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCAL_CODE = LOCATION_ID)
JOIN NATIONAL USING(NATIONAL_CODE)
WHERE NATIONAL_CODE IN('KO', 'JP');

--9. 같은 부서에 근무하는 직원들의 사원명, 부서명, 동료이름을
--조회하시오. (SELF JOIN 사용)
SELECT E1.EMP_NAME AS "사원명", DEPT_TITLE AS "부서명", E2.EMP_NAME AS "동료이름"
FROM EMPLOYEE E1
JOIN DEPARTMENT ON (DEPT_ID = DEPT_CODE)
JOIN EMPLOYEE E2 USING(DEPT_CODE)
WHERE E1.EMP_NAME != E2.EMP_NAME;

--10. 보너스 포인트가 없는 직원들 중에서 직급이 차장과
--사원인 직원들의 사원명, 직급명, 급여를 조회하시오.
--단, JOIN과 IN을 사용할 것
SELECT EMP_NAME AS "사원명", JOB_NAME AS "직급명", SALARY AS "급여"
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
WHERE JOB_CODE IN('J4', 'J7');

--11. 재직중인 직원과 퇴사한 직원의 수를 조회하시오.
SELECT DECODE(ENT_YN, 'Y', '퇴사', 'N', '재직') AS "재직여부",
COUNT(*) AS "인원 수"
FROM EMPLOYEE
GROUP BY DECODE(ENT_YN, 'Y', '퇴사', 'N', '재직');

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE
WHERE SALARY > 3000000;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE
WHERE SALARY > 3000000;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE
WHERE SALARY > 3000000;

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE
WHERE SALARY > 3000000;

--SUBQUERY
--SUBQUERY를 사용하지 않을 때
SELECT AVG(SALARY) FROM EMPLOYEE;
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3040000;

--SUBQUERY를 사용할 때
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE);

SELECT * FROM EMPLOYEE;
--단일행 서브쿼리
--전지연 직원의 관리자 이름 출력
--1. 전지연 직원의 MANAGER_ID를 구하고
--2. 구한 값을 바탕으로 이름 출력
SELECT EMP_NAME
FROM EMPLOYEE
WHERE EMP_ID = (SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME = '전지연');

--1. 윤은해와 급여가 같은 사원들을 검색해서 사원번호, 이름 ,급여 출력
--단, 윤은해는 출력 x
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY = (SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME = '윤은해')
AND EMP_NAME != '윤은해';

--2. EMPLOYEE 테이블에서 급여가 가장 많은 사람과 가장 적은 사람 출력
--사번, 이름, 급여
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE)
OR SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE);

--3. D1, D2 부서에서 근무하는 사원들 중 기본급여가 D5 부서의 평균 월급보다 많은 사람들만
--부서 번호, 사번, 이름, 월급 출력
SELECT DEPT_CODE, EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE IN('D1', 'D2')
AND SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = 'D5');

--다중행 서브쿼리
--단일행 서브쿼리로 송종기가 속한 부서의 사원정보 출력(전체정보)
SELECT * FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME = '송종기');

--단일행 서브쿼리로 박나라가 속한 부서의 사원정보 출력(전체정보)
SELECT * FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME = '박나라');

--단일행 서브쿼리로 박나라 또는 송종기가 속한 부서의 사원정보 출력(전체정보)
SELECT * FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME = '박나라')
OR DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME = '송종기');

SELECT * FROM EMPLOYEE
WHERE DEPT_CODE IN((SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME = '박나라'),
(SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME = '송종기'));

--다중행 서브쿼리로 박나라 또는 송종기가 속한 부서의 사원정보 출력(전체정보)
SELECT * FROM EMPLOYEE
WHERE DEPT_CODE IN(SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN('박나라', '송종기'));

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > ANY(2000000, 5000000);

SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > ALL(2000000, 5000000);

SELECT EMP_NAME, MANAGER_ID, BONUS FROM EMPLOYEE E
WHERE EXISTS(SELECT EMP_NAME FROM EMPLOYEE M
WHERE NVL(M.BONUS, 0) >= 0.3);

--부서별 최고 급여를 받는 직원의 이름, 직급, 부서, 급여 조회
SELECT EMP_NAME, JOB_CODE, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY IN(SELECT MAX(SALARY) FROM EMPLOYEE
GROUP BY DEPT_CODE);

--다중열
--퇴사한 여직원과 같은 부서, 같은 직급에 해당하는 사원의
--이름, 직급, 부서 조회
SELECT EMP_NAME, JOB_CODE, DEPT_CODE
FROM EMPLOYEE
WHERE (DEPT_CODE, JOB_CODE) IN (SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE
WHERE SUBSTR(EMP_NO, 8, 1) = 2 AND ENT_YN = 'Y');

SELECT MAX(SALARY), DEPT_CODE FROM EMPLOYEE
GROUP BY DEPT_CODE;
SELECT EMP_NAME, JOB_CODE, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE (SALARY, DEPT_CODE) IN(SELECT MAX(SALARY), DEPT_CODE FROM EMPLOYEE
GROUP BY DEPT_CODE);
