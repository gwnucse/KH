
SET SERVEROUTPUT ON;

--1. BASIC LOOP : 조건 없이 무한 반복
DECLARE
    I NUMBER := 1;
BEGIN
    LOOP        --반복 시작
        DBMS_OUTPUT.PUT_LINE(I);
        I := I + 1;
        IF I > 5 
            THEN EXIT;
        END IF;
    END LOOP;   --반복 끝지점
END;
/

--2. FOR LOOP
DECLARE
BEGIN
    FOR I IN REVERSE 1..5 LOOP
        DBMS_OUTPUT.PUT_LINE(I);
    END LOOP;
END;
/

DECLARE
    USERINFO EMPLOYEE%ROWTYPE;
BEGIN
    FOR I IN 0..22 LOOP
        SELECT *
        INTO USERINFO
        FROM EMPLOYEE WHERE EMP_ID = 200 + I;
        DBMS_OUTPUT.PUT_LINE('이름 : ' || USERINFO.EMP_NAME);
        DBMS_OUTPUT.PUT_LINE('급여 : ' || USERINFO.SALARY);
        DBMS_OUTPUT.PUT_LINE(' ');
    END LOOP;
END;
/

--WHILE
DECLARE
    I NUMBER := 1;
BEGIN
    WHILE I <= 5 LOOP
        DBMS_OUTPUT.PUT_LINE(I);
        I := I + 1;
    END LOOP;
END;
/

-- TOP N 분석을 위한 PL/SQL을 만들어라
-- '급여'/'보너스'/'입사일'
-- 무조건 1위~5위까지를 출력하는 PL/SQL을 만들어라.
SELECT 순위, EMP_NAME, SALARY
FROM (
    SELECT EMP_NAME, SALARY,
    RANK() OVER(ORDER BY SALARY DESC) AS 순위
    FROM EMPLOYEE
)
WHERE 순위 = 2;

SELECT EMP_NAME, NVL(BONUS, 0) AS BONUS,
RANK() OVER(ORDER BY BONUS DESC NULLS LAST) AS 순위
FROM EMPLOYEE;

SELECT EMP_NAME, NVL(BONUS, 0)
FROM (
    SELECT EMP_NAME, NVL(BONUS, 0) AS BONUS,
    ROW_NUMBER() OVER(ORDER BY BONUS DESC NULLS LAST) AS 순위
    FROM EMPLOYEE
)
WHERE 순위 = 3;

--ROWNUM을 정렬을 하면서 쓰기 위해서는 FROM절을 2번 묶어야 함
SELECT M.*
FROM (
    SELECT ROWNUM AS RNUM, E.*
    FROM (
        SELECT   EMP_NAME,BONUS FROM EMPLOYEE
        ORDER BY BONUS DESC NULLS LAST
    ) E
) M
WHERE M.RNUM = 2;

SELECT ROWNUM AS RNUM, E.*
FROM (
    SELECT EMP_NAME, BONUS FROM EMPLOYEE
    ORDER BY BONUS DESC NULLS LAST
) E;

DECLARE
    EMP EMPLOYEE%ROWTYPE;
    SEL_LANK VARCHAR2(20);
BEGIN
    SEL_LANK := '&랭킹';
    
    DBMS_OUTPUT.PUT_LINE('-------- ' || SEL_LANK || ' 랭킹 TOP 5 --------');
    
    FOR I IN 1..5 LOOP
        IF SEL_LANK = '급여'
        THEN
            SELECT EMP_NAME, SALARY
            INTO EMP.EMP_NAME, EMP.SALARY
            FROM (
                SELECT EMP_NAME, SALARY,
                ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS 순위
                FROM EMPLOYEE)
            WHERE 순위 = I;
            DBMS_OUTPUT.PUT_LINE('랭킹 : ' || I || '/이름 : ' || EMP.EMP_NAME ||'/급여 : ' || EMP.SALARY);
        ELSIF SEL_LANK = '보너스'
        THEN
            SELECT EMP_NAME, NVL(BONUS, 0)
            INTO EMP.EMP_NAME, EMP.BONUS
            FROM (
                SELECT EMP_NAME, BONUS,
                ROW_NUMBER() OVER(ORDER BY BONUS DESC NULLS LAST) AS 순위
                FROM EMPLOYEE)
            WHERE 순위 = I;
            DBMS_OUTPUT.PUT_LINE('랭킹 : ' || I || '/이름 : ' || EMP.EMP_NAME ||'/보너스 : ' || EMP.BONUS || '%');
        ELSIF SEL_LANK = '입사일'
        THEN 
            SELECT EMP_NAME, HIRE_DATE
            INTO EMP.EMP_NAME, EMP.HIRE_DATE
            FROM (
                SELECT EMP_NAME, HIRE_DATE,
                ROW_NUMBER() OVER(ORDER BY HIRE_DATE) AS 순위
                FROM EMPLOYEE)
            WHERE 순위 = I;
            DBMS_OUTPUT.PUT_LINE('랭킹 : ' || I || '/이름 : ' || EMP.EMP_NAME ||'/입사일 : ' || EMP.HIRE_DATE);
        ELSE
            DBMS_OUTPUT.PUT_LINE('잘못 입력하셨습니다.');
            EXIT;
        END IF;
    END LOOP;
END;
/

DECLARE
    USERINFO EMPLOYEE%ROWTYPE;
    N NUMBER := 1;
BEGIN
    LOOP
    SELECT *
    INTO USERINFO
    FROM EMPLOYEE
    WHERE EMP_ID = 200 + N;
    DBMS_OUTPUT.PUT_LINE('이름 : ' || USERINFO.EMP_NAME);
    DBMS_OUTPUT.PUT_LINE('급여 : ' || USERINFO.SALARY);
    DBMS_OUTPUT.PUT_LINE('------------------');
    N := N + 1;
    END LOOP;
EXCEPTION
    WHEN NO_DATA_FOUND
    THEN DBMS_OUTPUT.PUT_LINE('데이터가 없습니다.');
END;
/

--TRIGGER
CREATE TABLE TRI_MEMBER
AS
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE WHERE 1=0;

CREATE TABLE TRI_DEL_MEMBER(
    EMP_ID NUMBER,
    EMP_NAME VARCHAR(20),
    OUT_DATE DATE
);

INSERT INTO TRI_MEMBER VALUES(100, '박태규', 70000000);
INSERT INTO TRI_MEMBER VALUES(101, '김규형', 50000000);
INSERT INTO TRI_MEMBER VALUES(102, '김재원', 30000000);
INSERT INTO TRI_MEMBER VALUES(103, '지유진', 60000000);
INSERT INTO TRI_MEMBER VALUES(104, '박상우', 40000000);

SELECT * FROM TRI_MEMBER;
SELECT * FROM TRI_DEL_MEMBER;

CREATE OR REPLACE TRIGGER MEM_DEL_TRG
AFTER DELETE
ON TRI_MEMBER
FOR EACH ROW
BEGIN
    INSERT INTO TRI_DEL_MEMBER VALUES(
        --삭제된 사번, 삭제된 이름, SYSDATE
        :OLD.EMP_ID, :OLD.EMP_NAME, SYSDATE
    );
END;
/

CREATE OR REPLACE TRIGGER MEM_DEL_TRG
AFTER DELETE
ON TRI_MEMBER
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('데이터가 삭제되었습니다');
END;
/

CREATE OR REPLACE TRIGGER MEM_DEL_TRG
AFTER DELETE
ON TRI_MEMBER
BEGIN
    DBMS_OUTPUT.PUT_LINE('데이터가 삭제되었습니다');
END;
/

DELETE FROM TRI_MEMBER
WHERE EMP_NAME = '박상우';
DELETE FROM TRI_MEMBER;
COMMIT;

CREATE OR REPLACE TRIGGER TRI_MEM_INSERT_TRG
AFTER INSERT
ON TRI_MEMBER
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE(:NEW.EMP_NAME || '님이 입사하셨습니다.');
END;
/

CREATE OR REPLACE TRIGGER TRI_MEM_UPDATE
AFTER UPDATE
ON TRI_MEMBER
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE(:OLD.EMP_NAME||' -> '||:NEW.EMP_NAME);
END;
/

UPDATE TRI_MEMBER SET EMP_NAME = '김희범'
WHERE EMP_ID = 104;
UPDATE TRI_MEMBER SET EMP_NAME = '김규형'
WHERE EMP_ID = 104;
UPDATE TRI_MEMBER SET EMP_NAME = '이지훈'
WHERE EMP_ID = 104;
UPDATE TRI_MEMBER SET EMP_NAME = '김규형'
WHERE EMP_ID = 104;

CREATE TABLE LOG_TBL(
    EMP_ID NUMBER,
    CONTENT VARCHAR2(200),
    MODIFY_DATE DATE
);

SELECT * FROM LOG_TBL;

--수정 로그 트리거
CREATE OR REPLACE TRIGGER TRI_MEM_UPDATE
AFTER UPDATE
ON TRI_MEMBER
FOR EACH ROW
BEGIN
    INSERT INTO LOG_TBL VALUES
    (:OLD.EMP_ID, :OLD.EMP_NAME||' -> '||:NEW.EMP_NAME, SYSDATE);
END;
/

SELECT * FROM TRI_DEL_MEMBER;

--TRIGGER 실습문제
--1. PCODE, DECODE는 시퀀스로 번호 책정
--2. 입출고 테입르의 PCODE는 상품테이블의 PECODE를 참조(외래키 설정)
--3. 입출고 테이블의 STATUS값은 '입고' 또는 '출고'만 가능
--4. 입고/출고가 발생하면 트리거를 통해 상품 테이블의 STOCK자동으로 변경

CREATE SEQUENCE SEQ_PCODE
START WITH 1
INCREMENT BY 1
NOMAXVALUE
NOCYCLE
NOCACHE;

CREATE TABLE PRODUCT(
    PCODE NUMBER PRIMARY KEY,
    PNAME VARCHAR2(30),
    BRAND VARCHAR2(30),
    PRICE NUMBER,
    STOCK NUMBER DEFAULT 0
);

CREATE SEQUENCE SEQ_DCODE
START WITH 1
INCREMENT BY 1
NOMAXVALUE
NOCYCLE
NOCACHE;

CREATE TABLE PRO_STATUS(
    DCODE NUMBER PRIMARY KEY,
    PCODE NUMBER REFERENCES PRODUCT(PCODE),
    PDATE DATE,
    AMOUNT NUMBER,
    STATUS VARCHAR2(10) CHECK (STATUS IN ('입고', '출고'))
);

SELECT * FROM PRODUCT;
SELECT * FROM PRO_STATUS;

INSERT INTO PRODUCT VALUES(
    SEQ_PCODE.NEXTVAL, '갤럭시 S20', '삼성', 1200000, DEFAULT);
INSERT INTO PRODUCT VALUES(
    SEQ_PCODE.NEXTVAL, '아이폰 11 PRO', '애플', 1500000, DEFAULT);
INSERT INTO PRO_STATUS VALUES(
    SEQ_DCODE.NEXTVAL, 1, SYSDATE, 5, '입고');
INSERT INTO PRO_STATUS VALUES(
    SEQ_DCODE.NEXTVAL, 1, SYSDATE, 3, '출고');
INSERT INTO PRO_STATUS VALUES(
    SEQ_DCODE.NEXTVAL, 2, SYSDATE, 10, '입고');
INSERT INTO PRO_STATUS VALUES(
    SEQ_DCODE.NEXTVAL, 2, SYSDATE, 4, '출고');

CREATE OR REPLACE TRIGGER TRG_PRO_STA
AFTER INSERT
ON PRO_STATUS
FOR EACH ROW
BEGIN
    IF :NEW.STATUS = '입고'
    THEN
        UPDATE PRODUCT SET STOCK = STOCK + :NEW.AMOUNT
        WHERE PCODE = :NEW.PCODE;
    ELSIF :NEW.STATUS = '출고'
    THEN
        UPDATE PRODUCT SET STOCK = STOCK - :NEW.AMOUNT
        WHERE PCODE = :NEW.PCODE;
    END IF;
END;
/
